<!DOCTYPE html>
<html>
<head>
    <title>Cube AR - Détection de surfaces</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        .controls {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 10px;
            z-index: 1000;
        }
        button {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 5px;
        }
        #info {
            position: fixed;
            top: 20px;
            left: 0;
            right: 0;
            text-align: center;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <div id="info">Déplacez votre téléphone pour détecter les surfaces</div>
    <div class="controls">
        <button id="start-ar">Démarrer AR</button>
        <button onclick="rotateBox()" style="display: none">Tourner</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let camera, scene, renderer, cube;
        let controller;
        let reticle;
        let isRotating = false;
        let hitTestSource = null;
        let hitTestSourceRequested = false;

        async function init() {
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Lumières
            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
            light.position.set(0.5, 1, 0.25);
            scene.add(light);

            // Réticule pour indiquer la surface détectée
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial()
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            // Gestionnaire de session AR
            document.querySelector('#start-ar').addEventListener('click', async () => {
                try {
                    await startAR();
                } catch (err) {
                    alert("WebXR n'est pas pris en charge par votre appareil");
                }
            });

            window.addEventListener('resize', onWindowResize, false);
        }

        async function startAR() {
            const session = await navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['hit-test']
            });

            session.addEventListener('end', () => {
                hitTestSourceRequested = false;
                hitTestSource = null;
            });

            renderer.xr.setReferenceSpaceType('local');
            await renderer.xr.setSession(session);

            document.querySelector('#start-ar').style.display = 'none';
            document.querySelector('button[onclick="rotateBox()"]').style.display = 'block';

            session.addEventListener('select', onSelect);
        }

        function onSelect() {
            if (reticle.visible) {
                // Créer le cube à l'emplacement du réticule
                const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0x4CC3D9,
                    transparent: true,
                    opacity: 0.8
                });
                cube = new THREE.Mesh(geometry, material);
                cube.position.setFromMatrixPosition(reticle.matrix);
                scene.add(cube);
            }
        }

        function rotateBox() {
            if (cube) {
                isRotating = true;
                setTimeout(() => {
                    isRotating = false;
                }, 2000);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        async function initHitTestSource(session, referenceSpace) {
            const viewerSpace = await session.requestReferenceSpace('viewer');
            hitTestSource = await session.requestHitTestSource({ space: viewerSpace });
        }

        renderer.setAnimationLoop((timestamp, frame) => {
            if (!frame) return;

            const session = frame.session;

            if (!hitTestSourceRequested) {
                session.requestReferenceSpace('local').then((referenceSpace) => {
                    initHitTestSource(session, referenceSpace);
                });
                hitTestSourceRequested = true;
            }

            if (hitTestSource) {
                const hitTestResults = frame.getHitTestResults(hitTestSource);
                if (hitTestResults.length) {
                    const hit = hitTestResults[0];
                    reticle.visible = true;
                    reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                } else {
                    reticle.visible = false;
                }
            }

            if (cube && isRotating) {
                cube.rotation.y += 0.1;
            }

            renderer.render(scene, camera);
        });

        init();
    </script>
</body>
</html>
